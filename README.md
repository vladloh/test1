# Тестовое задание
Реализован класс, который помогает дополнить запрос по префиксу слова.

# Описание задания
Программе даётся художественный текст. 
Она должна его обработать, сделав словарь, в котором для каждого слова хранится его частота встречаемости.  
После обработки текста должна быть возможность по префиксу строки находить слова, которые вероятнее всего будут напечатаны далее.  
В качестве критерия вероятности выступает частота упоминания в предложенном тексте.  

# Использование

```
from classes import Autocompletor

autocompletor = Autocompletor()
autocompletor.build_dictionary()

res = autocompletor.search_top_k_strings("th")
print(res) # ['the', 'that', 'this', 'thou', 'thy', 'thee', 'then', 'they', 'than', 'their']

res = autocompletor.search_top_k_strings("scan")
print(res) # ['scandal', 'scandalous', 'scant']

res = autocompletor.search_top_k_strings("q")
print(res) # ['queen', 'quarrel', 'quickly', 'quiet', 'quoth', 'quick', 'question', 'quite', 'quit', 'quench']

```

# Описание решения
Для того, чтобы хранить слова, помимо обычного dict я решил использовать префиксное дерево (класс `PrefixTree`).  
Преимущество данного метода заключается в скорости. Обычный способ, который перебирает все слова из словаря, работает пропорционально размеру словаря, что является недопустимым при большом числе запросов.   
Используя префиксное дерево, я научился гораздо быстрее находить лучшие варианты.   
Помимо обычной структуры prefix tree я добавил в каждую вершину отсортированный по встречаемости список строк, которые начинаются с данного префикса. Для этого мне потребовалось `O(n * h)` времени и памяти, где `n` --- число уникальных слов, а `h` --- средняя глубина дерева (то есть средняя длина строк).   
Благодаря такому подходу я научился автодополнять строки за линейное от её размеров время, что по сути является константой.  
Для этого мне нужно всего лишь дойти по дереву до вершины, которая отвечает за префикс, и взять первые k элементов из отсортированного списка слов.  
